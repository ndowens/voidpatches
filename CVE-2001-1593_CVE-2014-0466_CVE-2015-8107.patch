From 89250b2a63e5be88f7b458effc29d8420640801b Mon Sep 17 00:00:00 2001
From: David Seifert <soap@gentoo.org>
Date: Sun, 17 Sep 2017 23:31:56 +0200
Subject: [PATCH] Add fix for CVE-2015-8107

---
 contrifixps.in |  2 +-
 contrifixps.m4 |  2 +-
 lioutput.c     | 71 ++++++++++++++++++++++--------------------------
 liparseppd.y   |  2 +-
 lipsgen.c      |  2 +-
 liroutines.c   | 47 ++++++++++++++++++++++++++++++++
 liroutines.h   |  3 +-
 src/parsessh.y   |  2 +-
 8 files changed, 86 insertions(+), 45 deletions(-)

diff --git contrifixps.in contrifixps.in
index af424a3..6c06825 100644
--- contrifixps.in
+++ contrifixps.in
@@ -389,7 +389,7 @@ if test $task != check; then
   	eval "$command" ;;
       gs)
         $verbose "$program: making a full rewrite of the file ($gs)." >&2
-  	$gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite -sOutputFile=- -c save pop -f $file ;;
+  	$gs -q -dSAFER -dNOPAUSE -dBATCH -sDEVICE=pswrite -sOutputFile=- -c save pop -f $file ;;
     esac
   )
 fi
diff --git contrifixps.m4 contrifixps.m4
index 002449e..84d4178 100644
--- contrifixps.m4
+++ contrifixps.m4
@@ -307,7 +307,7 @@ if test $task != check; then
   	eval "$command" ;;
       gs)
         $verbose "$program: making a full rewrite of the file ($gs)." >&2
-  	$gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite -sOutputFile=- -c save pop -f $file ;;
+  	$gs -q -dSAFER -dNOPAUSE -dBATCH -sDEVICE=pswrite -sOutputFile=- -c save pop -f $file ;;
     esac
   )
 fi
diff --git lioutput.c lioutput.c
index b5fc37d..449df0c 100644
--- lioutput.c
+++ lioutput.c
@@ -1,30 +1,23 @@
-/*
- * output.c
- *
- * routines for ram-diverted output
- * Copyright (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
- * Copyright (c) 1995, 96, 97, 98, 99 Akim Demaille, Miguel Santana
- * $Id: output.c,v 1.1.1.1.2.1 2007/12/29 01:58:21 mhatta Exp $
- */
+/* output.c - routines for ram-diverted output
+   Copyright 1988-2017 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include <config.h>
 
-/*
- * This file is part of a2ps.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; see the file COPYING.  If not, write to
- * the Free Software Foundation, 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
 #include "a2ps.h"
 #include "jobs.h"
 #include "routines.h"
@@ -60,7 +53,7 @@ struct derivation
   delayed_routine_t delayed_routine;
   void * delayed_routine_arg;
   int * delayed_int;
-  uchar ** delayed_string;
+  unsigned char ** delayed_string;
   struct output * delayed_chunk;
 };
 
@@ -76,7 +69,7 @@ struct output
 static struct derivation *
 new_derivation (enum derivation_type type)
 {
-  struct derivation * res = XMALLOC (struct derivation, 1);
+  struct derivation * res = XMALLOC (struct derivation);
   res->type = type;
   return res;
 }
@@ -84,7 +77,7 @@ new_derivation (enum derivation_type type)
 static void
 derivation_self_print (struct derivation * derivation, FILE * stream)
 {
-  fprintf (stream, "At %x: ", (int) derivation);
+  fprintf (stream, "At %p: ", derivation);
   switch (derivation->type)
     {
     case nothing:
@@ -112,7 +105,7 @@ derivation_self_print (struct derivation * derivation, FILE * stream)
       break;
     }
 }
-
+
 /************************************************************************/
 /*		Output maintenance					*/
 /************************************************************************/
@@ -124,7 +117,7 @@ output_new (const char * name)
 {
   struct output * res = NULL;
 
-  res = XMALLOC (struct output, 1);
+  res = XMALLOC (struct output);
   res->name = name;
   res->chunk = ds_new (MIN_CONTENT, ds_geometrical, 2);
   res->derivations = da_new ("derivations", MIN_DERIVATIONS,
@@ -172,7 +165,7 @@ output_is_to_void (struct output * out)
 {
   return out->to_void;
 }
-
+
 /************************************************************************/
 /*		Putting stuff in the output				*/
 /************************************************************************/
@@ -212,7 +205,7 @@ output (out, format, va_alist)
  * Add C to the end of output
  */
 void
-output_char (struct output * out, uchar c)
+output_char (struct output * out, unsigned char c)
 {
   if (out->to_void)
     return;
@@ -278,7 +271,7 @@ output_delayed_int (struct output * out, int * ptr)
  * The value pointed will be read only when undiverting
  */
 void
-output_delayed_string (struct output * out, uchar ** ptr)
+output_delayed_string (struct output * out, unsigned char ** ptr)
 {
   struct derivation *tmp;
 
@@ -291,7 +284,7 @@ output_delayed_string (struct output * out, uchar ** ptr)
   output_char (out, '\0');
   da_append (out->derivations, tmp);
 }
-
+
 /* FIXME: Must be robust to missing arguments */
 #define GET_TOKEN(from) (strtok ((from), " \t\n"))
 #define GET_LINE_TOKEN(from) (strtok ((from), "\n"))
@@ -523,9 +516,9 @@ output_file (struct output * out, a2ps_job * job,
 	token = GET_LINE_TOKEN (buf + strlen (EXPAND_TAG));
 	expansion = ((char *)
 		     expand_user_string (job, FIRST_FILE (job),
-					 (const uchar *) "Expand: requirement",
-					 (const uchar *) token));
-	output (dest, expansion);
+					 (const unsigned char *) "Expand: requirement",
+					 (const unsigned char *) token));
+	output (dest, "%s", expansion);
 	continue;
       }
 
@@ -541,7 +534,7 @@ output_file (struct output * out, a2ps_job * job,
   fclose (stream);
   free (filename);
 }
-
+
 /*
  * The derivation of a special kind will be emptied in STREAM
  */
diff --git liparseppd.y liparseppd.y
index a7558ba..c89d188 100644
--- liparseppd.y
+++ liparseppd.y
@@ -154,7 +154,7 @@ font_clause :
 void
 yyerror (const char *msg)
 {
-  error_at_line (1, 0, ppdfilename, ppdlineno, msg);
+  error_at_line (1, 0, ppdfilename, ppdlineno, "%s", msg);
 }
 
 /*
diff --git lipsgen.c lipsgen.c
index 29d2040..61e1103 100644
--- lipsgen.c
+++ lipsgen.c
@@ -232,7 +232,7 @@ output_marker (a2ps_job * job, const char * kind, uchar * marker)
     default:
       *buf = '\0';
       ps_escape_char (job, cp[i], buf);
-      output (jdiv, (char *) buf);
+      output (jdiv, "%s", (char *) buf);
       break;
     }
   }
diff --git liroutines.c liroutines.c
index 2997b18..41c3ab1 100644
--- liroutines.c
+++ liroutines.c
@@ -242,3 +242,50 @@ unlink2 (PARAM_UNUSED void * dummy, const char * filename)
   /* Don't complain if you can't unlink.  Who cares of a tmp file? */
   unlink (filename);
 }
+
+/*
+ * Securely generate a temp file, and make sure it gets
+ * deleted upon exit.
+ */
+static char **	tempfiles;
+static unsigned	ntempfiles;
+
+static void
+cleanup_tempfiles()
+{
+	while (ntempfiles--)
+		unlink(tempfiles[ntempfiles]);
+}
+
+char *
+safe_tempnam(const char *pfx)
+{
+	char	*dirname, *filename;
+	int	fd;
+
+	if (!(dirname = getenv("TMPDIR")))
+		dirname = "/tmp";
+
+	tempfiles = (char **) realloc(tempfiles,
+			(ntempfiles+1) * sizeof(char *));
+	if (tempfiles == NULL)
+		return NULL;
+
+	filename = malloc(strlen(dirname) + strlen(pfx) + sizeof("/XXXXXX"));
+	if (!filename)
+		return NULL;
+
+	sprintf(filename, "%s/%sXXXXXX", dirname, pfx);
+
+	if ((fd = mkstemp(filename)) < 0) {
+		free(filename);
+		return NULL;
+	}
+	close(fd);
+
+	if (ntempfiles == 0)
+		atexit(cleanup_tempfiles);
+	tempfiles[ntempfiles++] = filename;
+
+	return filename;
+}
diff --git liroutines.h liroutines.h
index 3308990..c7cf450 100644
--- liroutines.h
+++ liroutines.h
@@ -255,7 +255,8 @@ FILE * xwpopen PARAMS ((const char * command));
 /* If _STR_ is not defined, give it a tempname in _TMPDIR_ */
 #define tempname_ensure(Str)				\
 do {							\
-  (Str) = (Str) ? (Str) : tempnam (NULL, "a2_");	\
+  (Str) = (Str) ? (Str) : safe_tempnam("a2_");	\
 } while (0)
+char * safe_tempnam(const char *);
 
 #endif
diff --git src/parsessh.y src/parsessh.y
index 21e9559..569fdb6 100644
--- src/parsessh.y
+++ src/parsessh.y
@@ -740,7 +740,7 @@ exception_def_opt:
 void
 yyerror (const char *msg)
 {
-  error_at_line (1, 0, sshfilename, sshlineno, msg);
+  error_at_line (1, 0, sshfilename, sshlineno, "%s", msg);
 }
 
 /*
-- 
2.20.1

